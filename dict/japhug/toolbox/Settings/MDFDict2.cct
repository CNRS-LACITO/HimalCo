c ====================================================================
c MDFDICT2.CCT  Format lexical fields for printing a dictionary
c For Shoebox versions 5.0
c See the *** comments to learn how to modify this change table.
c --------------------------------------------------------------------
c
c Input:     A Standard Format lexical database with MDF markers.
c            This change table assumes that Shoebox and MDFDICT1.CCT have
c            inserted user-option fields preceding the data fields,
c            removed all data fields not to be printed,
c            removed "empty fields" that contain only white space, and
c            guaranteed that a space separates marker from field contents.
c Output:    A Standard Format file that is formatted for printing:
c            a) data fields are rearranged into the standard order,
c            b) labels and punctuation are inserted,
c            c) paragraph- and character-style markers are inserted.
c
c            Shoebox uses one of the MDF_*3.CCT change tables to change
c            the labels in this table's output. It then reads that output
c            using the "MDF Rich Text Format" MDF_RTF.TYP database type,
c            and finally exports it as an .RTF document.
c
c 1995       David F. Coward (david_coward@sil.org)
c            SIL, Kotak Pos 1050, Ambon, Maluku 97001 INDONESIA
c            MDFDICT.CCT change table in MDF version 1.1c for DOS
c 1996-08-10 Mark R. Pedrotti (mark_pedrotti@sil.org)
c            JAARS, P.O. Box 248, Waxhaw, NC 28173-0248 USA
c            Added gOptionFields group for MDF in Shoebox 3.0
c            Shoebox inserts section headings from Sort Order Properties.
c 1997-01-26 MRP - Shoebox 3.07
c            Remove limit of five examples using David Bevan's
c            modifications from version 2.3 of the "MDF WINWORD6 KIT-PNG"
c 1997-05-02 MRP - Updates after Shoebox 3.07
c            Reorganize field marker matching and data field output
c            to allow changes to punctuation for non-Roman scripts.
c            Simplify output of definitions so that \_Triglot not needed.
c            Prepare to add Total number of entries check box.
c 1997-05-03 Work on embedded character styles, especially CTW-style |u{...}.
c 1997-08-27 MRP - Bundles and field order for National Triglot.
c            Add \lv Lexical function (v)
c 1997-09-17 MRP - Add Paradigm bundle \pdl \pdv \pde \pdn \pdr
c 1997-09-19 MRP - Use {emdash} instead of numeric character code
c 1997-09-24 MRP - No longer consider \xg an MDF field
c            \pc .G. -> \px Graphic; otherwise -> \pc Picture
c 1997-09-26 MRP - Change the logic for "Sort by \lc citation form"
c 1997-11-25 MRP - Allow multiple \lv sub-bundles in an \lf bundle
c            (see mdfdict1.cct)
c 1997-12-01 MRP - Allow multiple \pdv sub-bundles in a \pdl bundle.
c            Remove SortByCitationForm switch which isn't used any more
c            and add pdlPrev. (We're up to the limit of switches again!)
c 1997-12-04 MRP - Change notation for "special symbols" to |{emdash} etc.
c 1998-01-16 MRP - Make order of Reversal, Word gloss, Usage, Encyclopedic
c            info, and Only-restrictions groups of fields primary-secondary
c            audience languages in a Triglot.
c 1998-04-03 MRP - Don't use |fs style for period in \ps and \pn.
c 1998-04-21 MRP - Remove unused nounder switch. Separate v and vhm
c            to correctly format vernacular fields like \cf Cross-reference
c            which have homonym numbers and \xv Example (v) which don't.
c            Change uc to ui for English, national, and regional fields
c            when they are the secondary audience in a triglot.
c 1998-04-25 MRP - Save 17 switches by using ifneq(1s) '' begin ... end endif
c            idiom instead of if(1s) ... endif for specific paradigm fields.
c            Revise character style logic for MDF, MS, and CTW formats.
c 1999-03-22 MRP - In a Triglot Dictionary, punctuate each definition
c            with |fs{.} instead of separating them with |fs{;}.
c 1999-03-29 MRP - One label for the entire "bundle" of fields:
c            Reversal, Word-level [gloss], Usage, Restrict.
c 1999-04-02 MRP - Convert |fvlink{...} subfields in web pages
c            to ordinary |fv{...} subfields in printed documents.
c 1999-08-11 MRP - Don't insert a |fs{;} semicolon after subentries
c            that aren't immediately followed by a part of speech.
c 2000-07-21 MRP - Omit extra Entry Paragraph at the end.
c            In the MDF .dot files, the FinishExportingFromShoebox
c            causes entries at the end of the double-column sections
c            to line up by deleting the paragraphs that Shoebox inserts.
c            This way, the section breaks directly follow the paragraph marks
c            of the last entry, indented, block, or finderlist paragraph.

c 2006-01-25 KB modified to repair improper placement of picture relative
c	     to the Letter section markers.
c            (actually this still has a problem...)
c 2006-05-11 KB modified to add ability to put dots in glosses
c	     instead of underlines (both are enabled)
c            see group(gGloss)
c 2008-05-28 KB cleaned up bad if structures
c               endif is wrong inside nested structures 
c               -- ends all conditions
c               must use begin...end when nesting
c               endif works fine for simple if's which aren't nested

c ====================================================================
begin >
    store(Backslash) '\' endstore
    store(Newline) nl endstore
    store(LexicalFunctionSeparator) ':=' endstore
    store(WS) ' ' nl d9 endstore  c White space: Space, newline, tab
    store(punct) ' .,;:"]|\=+)`></?' "'" endstore  c stop chr styles
    store(number) '1234567890' endstore  c homonymn numbers
    store(total) '0' endstore  c Initialize counter for entries

    c Default options    
    set(English)  c Audience: English
    clear(IncludeLexemeWithCitationForm)  c DO NOT Include \lx lexeme with \lc
    clear(AlternateHierarchy)  c Standard hierarchy: \lx \se \ps \sn
    set(TwoColumns)  c Page format: Two columns
    set(Total)  c Page format: Total number of entries
    use(gOptionFields)


c ====================================================================
c DEFINITIONS
c --------------------------------------------------------------------

c ====================================================================
define(dEndfile) >  c Output the final subrecord
    endstore
    do(dOutput)
    c 1996-08-10 MRP: What FOLLOWS is a Single-column Section
    c 1997-01-26 MRP: Section breaks needed only for double-column
    c 2000-07-21 MRP: Omit extra Entry Paragraph at the end
    c if(TwoColumns) begin nl '\EP' nl '\SS' nl end
    if(TwoColumns) begin nl '\SS' nl end
    if(Total)
      begin
        '\CP Total number of entries: ' out(total) nl
      end
    else
      begin
        '\CP' nl  c 1997-10-07 MRP: Needed to cause Shoebox 3.09
                  c File Export to output the last section break.
      end
    endfile

c ====================================================================
define(xvBundle) >  c Append example sentence fields in order
    if(xv) 
      begin
        append(xvBundle)
        set(xvBundle)
        if(rf) begin '\rf |fl{Ref: }' outs(rf) nl end
        '\xv ' outs(xv) nl
        if(English) 
          begin
            if(xe) begin '\xe ' outs(xe) nl end
            if(xn) begin '\xn ' outs(xn) nl end
            if(xr) begin '\xr ' outs(xr) nl end
          end 
        else 
          begin
            if(xn) begin '\xn ' outs(xn) nl end
            if(xr) begin '\xr ' outs(xr) nl end
            if(xe) begin '\xe ' outs(xe) nl end
          end   c if(English)
        endstore
      end 
    else 
      begin
        if(rf)
          begin
            append(xvBundle)
            set(xvBundle)
            '\rf |fl{Ref: }' outs(rf) nl
            endstore
          end
      end   c if(xv)
    clear(rf,xv,xe,xn,xr) store(rf,xv,xe,xn,xr) endstore

c --------------------------------------------------------------------
define(lfBundle) >  c Append lexical function fields in order
    c 1997-11-25 MRP: Allow multiple \lv sub-bundles in an \lf bundle
    c If there's an \lv right now AND there is OR has been an \lf
    clear(do_it)
    if(lv) 
      begin
        if(lf)       begin set(do_it) end
        if(lfBundle) begin set(do_it) end
      end   c if(lv)

    if(do_it) 
      begin
        append(lfBundle)
        if(lfBundle) begin '|fs{; }'             end set(lfBundle)
        if(lf)       begin '|fl{' outs(lf) ': }' end
        '|fv{' outs(lv) '}'
        if(English)
          begin
            if(le) begin "|fs{ '}|fe{" outs(le) "}|fs{'}" end
            if(ln) begin "|fs{ '}|fn{" outs(ln) "}|fs{'}" end
            if(lr) begin "|fs{ '}|fr{" outs(lr) "}|fs{'}" end
          end 
        else 
          begin
            if(ln) begin "|fs{ '}|fn{" outs(ln) "}|fs{'}" end
            if(lr) begin "|fs{ '}|fr{" outs(lr) "}|fs{'}" end
            if(le) begin "|fs{ '}|fe{" outs(le) "}|fs{'}" end
          end   c if(English)
        endstore
      end  c if(do_it)
    clear(lf,lv,le,ln,lr) store(lf,lv,le,ln,lr) endstore

c --------------------------------------------------------------------
define(cfBundle) >  c Append cross reference fields in order
    if(cf) 
      begin
        append(cfBundle)
        if(cfBundle) begin '|fs{; }' end set(cfBundle)
        '|fv{' outs(cf) '}'
        if(English) 
          begin
            if(ce) begin "|fs{ '}|fe{" outs(ce) "}|fs{'}" end
            if(cn) begin "|fs{ '}|fn{" outs(cn) "}|fs{'}" end
            if(cr) begin "|fs{ '}|fr{" outs(cr) "}|fs{'}" end
          end 
        else 
          begin
            if(cn) begin "|fs{ '}|fn{" outs(cn) "}|fs{'}" end
            if(cr) begin "|fs{ '}|fr{" outs(cr) "}|fs{'}" end
            if(ce) begin "|fs{ '}|fe{" outs(ce) "}|fs{'}" end
          end  c if(English)
        endstore
      end  c if(cf)
    clear(cf,ce,cn,cr) store(cf,ce,cn,cr) endstore

c --------------------------------------------------------------------
define(vaBundle) >  c Append variant fields in order
    if(va) 
      begin
        append(vaBundle)
        if(vaBundle) begin '|fs{; }' end set(vaBundle)
        '|fv{' outs(va) '}'
        if(English)
          begin
            if(ve) begin '|fs{ (}|fe{' outs(ve) '}|fs{)}' end
            if(vn) begin '|fs{ (}|fn{' outs(vn) '}|fs{)}' end
            if(vr) begin '|fs{ (}|fr{' outs(vr) '}|fs{)}' end
          end 
        else 
          begin
            if(vn) begin '|fs{ (}|fn{' outs(vn) '}|fs{)}' end
            if(vr) begin '|fs{ (}|fr{' outs(vr) '}|fs{)}' end
            if(ve) begin '|fs{ (}|fe{' outs(ve) '}|fs{)}' end
          end   c if(English)
        endstore
      end  c if(va)
    clear(va,ve,vn,vr) store(va,ve,vn,vr) endstore

c --------------------------------------------------------------------
define(etBundle) >  c Append etymology fields in order
    if(et) 
      begin
        append(etBundle)
        if(etBundle) begin '|fs{; }' end set(etBundle)
        outs(et)
        if(eg) begin " |fs{'}|fe{" outs(eg) "}|fs{'}" end
        if(es) begin         'fe{' outs(es) '}'       end  c 1999-03-29 MRP: fe
        if(ec) begin ' |fs{(}|fe{' outs(ec) '}|fs{)}' end
        endstore
      end  c if(et)
    clear(et,eg,es,ec) store(et,eg,es,ec) endstore

c --------------------------------------------------------------------
define(pdBundle) >  c Append paradigm form fields in order
    if(pd)
      begin
        append(pdBundle)
        if(pdBundle) begin '|fs{. }' end set(pdBundle)
        '|fl{Prdm: }' outs(pd)
        endstore
        clear(pdlPrev)  c 1997-12-01 MRP
      end  c if(pd)
    c 1997-12-01 MRP: Allow multiple \pdv sub-bundles in a \pdl bundle
    c If there's a \pdv right now AND there is a \pdl OR has been one
    c immediately preceding (i.e. not separated by a \pd Paradigm field).
    c Note: The logic is similar, but not identical, to lexical functions.
    clear(do_it)
    if(pdv) 
      begin
        if(pdl)     begin set(do_it) end
        if(pdlPrev) begin set(do_it) end
      end  c if(pdv)
    if(do_it)
      begin
        append(pdBundle)
        if(pdBundle) 
          begin
            if(pdl) begin '|fs{. }' else '|fs{; }' end
          end  c if(pdBundle)
        set(pdBundle)
        if(pdl) begin '|fl{' outs(pdl) ': }' set(pdlPrev) end
        '|fv{' outs(pdv) '}'
        if(English) 
          begin
            if(pde) begin "|fs{ '}|fe{" outs(pde) "}|fs{'}" end
            if(pdn) begin "|fs{ '}|fn{" outs(pdn) "}|fs{'}" end
            if(pdr) begin "|fs{ '}|fr{" outs(pdr) "}|fs{'}" end
          end 
        else 
          begin
            if(pdn) begin "|fs{ '}|fn{" outs(pdn) "}|fs{'}" end
            if(pdr) begin "|fs{ '}|fr{" outs(pdr) "}|fs{'}" end
            if(pde) begin "|fs{ '}|fe{" outs(pde) "}|fs{'}" end
          end  c if(English)
        endstore
      end  c if(do_it)
    clear(pd,pdl,pdv,pde,pdn,pdr) store(pd,pdl,pdv,pde,pdn,pdr) endstore

c ====================================================================
define(dOutput) >  c Output subrecord preceding \lx, \se, \ps, \pn, \sn

c Append "bundles" of fields in order so they're ready to output below
do(xvBundle)
do(lfBundle)
do(cfBundle)
do(vaBundle)
do(etBundle)
do(pdBundle)

c Output each field that was found in the subrecord
c To REORDER the fields, reorder the blocks used by each field:

if(lx) 
  begin
    nl  c Add space between records

    c KB: Original had \LS output at the end of this, but that sometimes
    c meant it came out before the picture stuff -- since the entry gets
    c output piecemeal. 
    c -------------------------------------------------------------
    if(px) begin '\px ' out(px) nl clear(px) end
    if(LP) begin        out(LP)    clear(LP) end

    c -------------------------------------------------------------
    '\EP' nl  c Entry Paragraph
    '\lx ' if(lc) begin out(lc) end else begin out(lx) end
    set(Headword)  c \lx \lc or \se
    if(hm) begin '|hm{' out(hm) '}' end    

    c 1997-09-26 MRP: In versions 3.0 through 3.07 we swapped
    c the \lx and \lc fields when sorting by \lc citation form.
    c Starting in version 3.09 we quit that approach, because
    c it's wrong if they have different language encodings.
    c That means that the old mdfdict2.cct does NOT work
    c with current versions of Shoebox and vice versa.
    if(IncludeLexemeWithCitationForm) 
      begin
        if(lc) 
          begin
            ifneq(lc) cont(lx)  c 1997-09-26 MRP 
              begin
                nl '\fv |fl{(from: }' out(lx) '|fl{)}'  c 1999-03-29 MRP: fv
              end
          end
      end    
    '|fs{ ' d9 '}' nl

    c 1996-08-14 MRP: The reason for marking the white space
    c as |fs is that if the last headword on the page had a \hm
    c then the space marked as \lx was used in the header STYLEREF.
    c Doing so also reduces the number of markers that require the
    c No Word Wrap property.
  end  c if(lx)

c ================= variant hierarchy schemes ===================
if(AlternateHierarchy)      c \lx \sn \se \ps
  begin
c ---------------------------------------------------------------
    if(sn) 
      begin                                 c Sense Number
        if(px) begin '\px ' out(px) nl clear(px) end
        '\IP' nl  c Indented Paragraph
        '\sn ' out(sn) ')|{~}' nl  c 1997-12-04 MRP: |{~} notation
      end
    c ---------------------------------------------------------------
    if(se) 
      begin                                 c Subentry
        if(px) begin '\px ' out(px) nl clear(px) end
        '\BP' nl  c Indented Paragraph
        '\se ' out(se) '|fs{ ' d9 '}' nl  c 1999-08-11 MRP
        set(Headword)
      end
    c ---------------------------------------------------------------
    if(ph) begin '\ph [' out(ph) ']' nl end   c Phonetic/phonemic
    c ---------------------------------------------------------------
    if(ps) 
      begin                                 c Part of Speech
        ifn(Headword) 
          begin  c If not the first \ps after the headword
            if(px) begin '\px ' out(px) nl clear(px) end
            '\BP |{emdash}' nl  c Block Paragraph em-dash
          end
        clear(Headword)
        if(pn)
          begin
            '\pn ' out(pn) '.' nl
          end
        else
          begin
            '\ps ' out(ps) '.' nl
          end
      end
c ================================================================
  end 
else 
  begin    c Standard hierarchy: \lx \se \ps \sn
c ----------------------------------------------------------------
    if(se) 
      begin                                  c Subentry
        if(px) begin '\px ' out(px) nl clear(px) end
        '\IP' nl  c Indented Paragraph
        '\se ' out(se) '|fs{ ' d9 '}' nl  c 1999-08-11 MRP
        set(Headword)
      end
    c ---------------------------------------------------------------
    if(ph) begin '\ph [' out(ph) ']' nl end   c Phonetic/phonemic
    c ---------------------------------------------------------------
    if(ps) 
      begin                                 c Part of Speech
        ifn(Headword) 
          begin  c If not the first \ps after the headword
            if(px) begin '\px ' out(px) nl clear(px) end
            '\BP |{emdash}' nl  c Block Paragraph em-dash
          end 
        clear(Headword)
        if(pn)
          begin
            '\pn ' out(pn) '.' nl
          end
        else
          begin
            '\ps ' out(ps) '.' nl
          end
      end
    c ----------------------------------------------------------------
    if(sn) 
      begin                                 c Sense Number
        if(px) begin '\px ' out(px) nl '\BP' nl clear(px) end
        '\sn ' out(sn) ')|{~}' nl  c 1997-12-04 MRP: |{~} notation
      end
c ----------------------------------------------------------------
  end
c ================== ends the variant hierarchy section ==========

c If there's no definition, use the gloss instead
ifn(dv) begin if(gv) begin store(dv) outs(gv) endstore set(dv) end end
ifn(de) begin if(ge) begin store(de) outs(ge) endstore set(de) end end
ifn(dn) begin if(gn) begin store(dn) outs(gn) endstore set(dn) end end
ifn(dr) begin if(gr) begin store(dr) outs(gr) endstore set(dr) end end

if(dv) begin '\dv ' out(dv) '|fs{.}' nl end

c ----------------------------------------------------------------
if(English) 
  begin  c Audience: English
    if(de) begin '\de ' out(de) '|fs{.}' nl end
  end

if(dn) 
  begin  c Definition-national
    '\dn ' out(dn) '|fs{.}' nl
  end

if(dr)
  begin  c Definition-regional
    '\dr ' out(dr) '|fs{.}' nl
  end 

ifn(English) 
  begin  c Audience: National
    if(de) begin '\de ' out(de) '|fs{.}' nl end
  end

c ----------------------------------------------------------------

c 1999-03-29 MRP: One label for the entire "bundle" of fields.
clear(do_it)
if(re) set(do_it) endif
if(rn) set(do_it) endif
if(rr) set(do_it) endif
if(do_it) '\fs |fl{Reversal:}' nl endif

if(English) 
  begin
    if(re) begin '\fe '                           out(re) '|fs{.}'  nl end
    if(rn) begin '\fn '                           out(rn) '|fs{.}'  nl end
    if(rr) begin '\fr '                           out(rr) '|fs{.}'  nl end
  end 
else 
  begin
    if(rn) begin '\fn '                           out(rn) '|fs{.}'  nl end
    if(rr) begin '\fr '                           out(rr) '|fs{.}'  nl end
    if(re) begin '\fe '                           out(re) '|fs{.}'  nl end
  end 

c 1999-03-29 MRP: One label for the entire "bundle" of fields.
clear(do_it)
if(we) set(do_it) endif
if(wn) set(do_it) endif
if(wr) set(do_it) endif
if(do_it) '\fs |fl{Word-level:}' nl endif


if(English) 
  begin
    if(we) begin '\fe '                           out(we) '|fs{.}'  nl end
    if(wn) begin '\fn '                           out(wn) '|fs{.}'  nl end
    if(wr) begin '\fr '                           out(wr) '|fs{.}'  nl end
  end 
else 
  begin
    if(wn) begin '\fn '                           out(wn) '|fs{.}'  nl end
    if(wr) begin '\fr '                           out(wr) '|fs{.}'  nl end
    if(we) begin '\fe '                           out(we) '|fs{.}'  nl end
  end

c ----------------------------------------------------------------
c the rest of the fields
if(lt)       "\lt |fl{Lit: }|fs{'}"           out(lt) "|fs{'.}" nl endif
if(sc)       '\sc '                           out(sc) '|fs{.}'  nl endif

if(xvBundle)                            out(xvBundle)              endif

c 1999-03-29 MRP: One label for the entire "bundle" of fields.
clear(do_it)
if(uv) set(do_it) endif
if(ue) set(do_it) endif
if(un) set(do_it) endif
if(ur) set(do_it) endif
if(do_it) '\fs |fl{Usage:}' nl endif

if(uv)       '\uv '                           out(uv) '|fs{.}'  nl endif

if(English) 
  begin
    if(ue) begin '\ue '                           out(ue) '|fs{.}'  nl end
    if(un) begin '\un '                           out(un) '|fs{.}'  nl end
    if(ur) begin '\ur '                           out(ur) '|fs{.}'  nl end
  end 
else 
  begin
    if(un) begin '\un '                           out(un) '|fs{.}'  nl end
    if(ur) begin '\ur '                           out(ur) '|fs{.}'  nl end
    if(ue) begin '\ue '                           out(ue) '|fs{.}'  nl end
  end

if(ev)       '\ev '                           out(ev) '|fs{.}'  nl endif

if(English) 
  begin
    if(ee) begin '\ee '                           out(ee) '|fs{.}'  nl end
    if(en) begin '\en '                           out(en) '|fs{.}'  nl end
    if(er) begin '\er '                           out(er) '|fs{.}'  nl end
  end 
else 
  begin
    if(en) begin '\en '                           out(en) '|fs{.}'  nl end
    if(er) begin '\er '                           out(er) '|fs{.}'  nl end
    if(ee) begin '\ee '                           out(ee) '|fs{.}'  nl end
  end 

c 1999-03-29 MRP: One label for the entire "bundle" of fields.
clear(do_it)
if(ov) set(do_it) endif
if(oe) set(do_it) endif
if(on) set(do_it) endif
if(or) set(do_it) endif
if(do_it) '\fs |fl{Restrict:}' nl endif

if(ov)       '\ov '                           out(ov) '|fs{.}'  nl endif

if(English) 
  begin
    if(oe) begin '\oe '                           out(oe) '|fs{.}'  nl end
    if(on) begin '\on '                           out(on) '|fs{.}'  nl end
    if(or) begin '\or '                           out(or) '|fs{.}'  nl end
  end 
else 
  begin
    if(on) begin '\on '                           out(on) '|fs{.}'  nl end
    if(or) begin '\or '                           out(or) '|fs{.}'  nl end
    if(oe) begin '\oe '                           out(oe) '|fs{.}'  nl end
  end

if(lfBundle) '\lf '                  out(lfBundle) '|fs{.}'  nl endif
if(sy)       '\fv |fl{Syn: }'           out(sy)    '|fs{.}'  nl endif  c 1999-03-29 MRP: fv
if(an)       '\fv |fl{Ant: }'           out(an)    '|fs{.}'  nl endif  c 1999-03-29 MRP: fv
if(mr)       '\mr |fl{Morph: }'         out(mr)    '|fs{.}'  nl endif
if(cfBundle) '\cf |fl{See: }'           out(cfBundle) '|fs{.}'  nl endif
if(mn)       '\fv |fl{See main entry: }' out(mn)   '|fs{.}'  nl endif  c 1999-03-29 MRP: fv
if(vaBundle) '\va |fl{Variant: }'       out(vaBundle) '|fs{.}'  nl endif

if(bw)       '\bw |fl{From: }'          out(bw)       '|fs{.}'  nl endif
if(etBundle) '\et |fl{Etym: }'          out(etBundle) '|fs{.}'  nl endif

if(pdBundle) '\pd '                     out(pdBundle) '|fs{.}'  nl endif

c 1999-03-29 MRP: fv
ifneq(sg) '' begin '\fv |fl{Sg: }'        out(sg) '|fs{.}'  nl end
ifneq(pl) '' begin '\fv |fl{Pl: }'        out(pl) '|fs{.}'  nl end
ifneq(rd) '' begin '\fv |fl{Redup: }'     out(rd) '|fs{.}'  nl end
ifneq(1s) '' begin '\fv |fl{1s: }'        out(1s) '|fs{.}'  nl end
ifneq(2s) '' begin '\fv |fl{2s: }'        out(2s) '|fs{.}'  nl end
ifneq(3s) '' begin '\fv |fl{3s: }'        out(3s) '|fs{.}'  nl end
ifneq(4s) '' begin '\fv |fl{3sn: }'       out(4s) '|fs{.}'  nl end
ifneq(1d) '' begin '\fv |fl{1d: }'        out(1d) '|fs{.}'  nl end
ifneq(2d) '' begin '\fv |fl{2d: }'        out(2d) '|fs{.}'  nl end
ifneq(3d) '' begin '\fv |fl{3d: }'        out(3d) '|fs{.}'  nl end
ifneq(4d) '' begin '\fv |fl{3dn: }'       out(4d) '|fs{.}'  nl end
ifneq(1p) '' begin '\fv |fl{1p: }'        out(1p) '|fs{.}'  nl end
ifneq(1i) '' begin '\fv |fl{1pi: }'       out(1i) '|fs{.}'  nl end
ifneq(1e) '' begin '\fv |fl{1px: }'       out(1e) '|fs{.}'  nl end
ifneq(2p) '' begin '\fv |fl{2p: }'        out(2p) '|fs{.}'  nl end
ifneq(3p) '' begin '\fv |fl{3p: }'        out(3p) '|fs{.}'  nl end
ifneq(4p) '' begin '\fv |fl{3pn: }'       out(4p) '|fs{.}'  nl end

if(tb)                                        out(tb)           nl '\BP' nl endif
                                                     
if(sd)       '\sd |fl{SD: }'              out(sd) '|fs{.}'  nl endif
if(is)       '\is |fl{Semantics: }'       out(is) '|fs{.}'  nl endif
if(th)       '\th |fl{Thes: }'            out(th) '|fs{.}'  nl endif

if(bb)       '\bb |fl{Read: }'            out(bb) '|fs{.}'  nl endif
if(pc)       '\fe |fs{(}'                 out(pc) '|fs{)}'  nl endif  c 1999-03-29 MRP:fe

if(nt)       '\nt |fl{[Note: }'           out(nt) '|fl{]}'  nl endif
if(np)       '\np |fl{[Phon: }'           out(np) '|fl{]}'  nl endif
if(ng)       '\ng |fl{[Gram: }'           out(ng) '|fl{]}'  nl endif
if(nd)       '\nd |fl{[Disc: }'           out(nd) '|fl{]}'  nl endif
if(na)       '\na |fl{[Anth: }'           out(na) '|fl{]}'  nl endif
if(ns)       '\ns |fl{[Socio: }'          out(ns) '|fl{]}'  nl endif
if(nq)       '\nq |fl{[Ques: }'           out(nq) '|fl{]}'  nl endif

if(so)       '\so |fl{[Source: }'         out(so) '|fl{]}'  nl endif
if(st)       '\st |fl{[Status: }'         out(st) '|fl{]}'  nl endif
if(dt)       '\dt '                       out(dt) '|fs{.}'  nl endif

if(??)       '\?? |fl{[?? }'              out(??) '|fl{]}'  nl endif


c if(LP) out(LP) endif c KB wrong place for output of this field

c --------------------------------------------------------------------

c Clear switches for all fields      c Clear stores for all fields
clear(lx,lc,hm,se,ph,ps,pn,sn)       store(lx,lc,hm,se,ph,ps,pn,sn)
clear(dv,gv)                         store(dv,gv)
clear(de,ge)                         store(de,ge)
clear(dn,gn)                         store(dn,gn)
clear(dr,gr)                         store(dr,gr)
clear(re,rn,rr)                      store(re,rn,rr)
clear(we,wn,wr)                      store(we,wn,wr)
clear(lt)                            store(lt)
clear(sc)                            store(sc)
clear(xvBundle,rf,xv,xe,xn,xr)       store(xvBundle,rf,xv,xe,xn,xr)
clear(uv,ue,un,ur)                   store(uv,ue,un,ur)
clear(ev,ee,en,er)                   store(ev,ee,en,er)
clear(ov,oe,on,or)                   store(ov,oe,on,or)
clear(lfBundle,lf,lv,le,ln,lr)       store(lfBundle,lf,lv,le,ln,lr)
clear(sy,an)                         store(sy,an)
clear(mr)                            store(mr)
clear(cfBundle,cf,ce,cn,cr)          store(cfBundle,cf,ce,cn,cr)
clear(mn)                            store(mn)
clear(vaBundle,va,ve,vn,vr)          store(vaBundle,va,ve,vn,vr)
clear(bw)                            store(bw)
clear(etBundle,et,eg,es,ec)          store(etBundle,et,eg,es,ec)
clear(pdBundle,pd)                   store(pdBundle,pd)
clear(pdl,pdv,pde,pdn,pdr,pdlPrev)   store(pdl,pdv,pde,pdn,pdr)
                                     store(sg,pl,rd)
                                     store(1s,2s,3s,4s)
                                     store(1d,2d,3d,4d)
                                     store(1p,1i,1e,2p,3p,4p)
clear(tb)                            store(tb)
clear(sd,is,th)                      store(sd,is,th)
clear(bb)                            store(bb)
clear(pc)                            store(pc)
clear(nt,np,ng,nd,na,ns,nq)          store(nt,np,ng,nd,na,ns,nq)
clear(so,st,dt,??)                   store(so,st,dt,??)
c clear(LP) store(LP)  c Letter paragraph c KB: don't clear this here
                                     endstore


c ====================================================================
group(gOptionFields)  c Shoebox inserts these fields preceding the data

'\_National' nl > clear(English)  c Audience: National
'\_SingleColumn' nl > clear(TwoColumns)
'\_IncludeLexemeWithCitationForm' nl > set(IncludeLexemeWithCitationForm)
'\_AlternateHierarchy' nl > next
'\_sn_se_ps' nl > set(AlternateHierarchy)  c \lx \sn \se \ps
'\_NoTotal' nl > clear(Total)

'\_' > store(omit) use(gUnknownOptionField)

nl > ''

'' > store(omit) use(gMain)

c --------------------------------------------------------------------
group(gUnknownOptionField)

nl fol(Backslash) > endstore use(gOptionFields)


c ====================================================================
group(gMain)   c Normal processing of fields starts here.

'\lx ' > do(dOutput) store(lx) set(lx) use(gField) set(v) incr(total)
'\lc ' >             store(lc) set(lc) use(gField)
'\hm ' >             store(hm) set(hm) use(gField)

'\se ' > do(dOutput) store(se) set(se) use(gField)
'\ph ' >             append(ph) if(ph) '|fs{; }' endif set(ph) use(gField)

'\ps ' > do(dOutput) store(ps) set(ps) use(gField)
'\pn ' >             c \pn occurs only for Audience: National
                     if(ps) clear(ps) endif  c Replace English \ps 
         do(dOutput) store(pn) set(pn,ps) use(gField)

'\sn ' > do(dOutput) store(sn) set(sn) use(gField)

'\pc .G.' > store(px) set(px) use(gField)

'\dv ' > append(dv) if(dv)      '; '       endif set(dv) use(gField) set(v)
'\de ' > append(de) if(de)      '; '       endif set(de) use(gField)
'\dn ' > append(dn) if(dn)      '; '       endif set(dn) use(gField) set(n)
'\dr ' > append(dr) if(dr)      '; '       endif set(dr) use(gField) set(r)

'\gv ' > append(gv) if(gv)      '; '       endif set(gv) use(gField) set(v)
'\ge ' > append(ge) if(ge)      ', '       endif set(ge) use(gGloss)
'\gn ' > append(gn) if(gn)      ', '       endif set(gn) use(gGloss)
'\gr ' > append(gr) if(gr)      ', '       endif set(gr) use(gGloss)

'\re ' > append(re) if(re)      ', '       endif set(re) use(gField)
'\rn ' > append(rn) if(rn)      ', '       endif set(rn) use(gField) set(n)
'\rr ' > append(rr) if(rr)      ', '       endif set(rr) use(gField) set(r)

'\we ' > append(we) if(we)      ', '       endif set(we) use(gField)
'\wn ' > append(wn) if(wn)      ', '       endif set(wn) use(gField) set(n)
'\wr ' > append(wr) if(wr)      ', '       endif set(wr) use(gField) set(r)

'\lt ' > append(lt) if(lt)  '|fs{; }'      endif set(lt) use(gField)
'\sc ' > append(sc) if(sc)  '|fs{; }'      endif set(sc) use(gField)

'\rf ' >   do(xvBundle)
           store(rf)                             set(rf) use(gField)
c KB Revised to remove invalid if(rf) and changed store(xv) to append(xv)
c (comparing to lv, might have intended if(xv) instead of if(rf) )
'\xv' nl > do(xvBundle)
'\xv ' >   do(xvBundle)
           append(xv)                            set(xv) use(gField) set(v)
'\xe ' > append(xe) if(xe)      ' '        endif set(xe) use(gField)
'\xn ' > append(xn) if(xn)      ' '        endif set(xn) use(gField) set(n)
'\xr ' > append(xr) if(xr)      ' '        endif set(xr) use(gField) set(r)
                                
'\uv ' > append(uv) if(uv)      ' '        endif set(uv) use(gField)
'\ue ' > append(ue) if(ue)      ' '        endif set(ue) use(gField)
'\un ' > append(un) if(un)      ' '        endif set(un) use(gField) set(n)
'\ur ' > append(ur) if(ur)      ' '        endif set(ur) use(gField) set(r)

'\ev ' > append(ev) if(ev)      ' '        endif set(ev) use(gField)
'\ee ' > append(ee) if(ee)      ' '        endif set(ee) use(gField)
'\en ' > append(en) if(en)      ' '        endif set(en) use(gField) set(n)
'\er ' > append(er) if(er)      ' '        endif set(er) use(gField) set(r)

'\ov ' > append(ov) if(ov)      ' '        endif set(ov) use(gField)
'\oe ' > append(oe) if(oe)      ' '        endif set(oe) use(gField)
'\on ' > append(on) if(on)      ' '        endif set(on) use(gField) set(n)
'\or ' > append(or) if(or)      ' '        endif set(or) use(gField) set(r)

'\lf' nl > do(lfBundle)
'\lf ' >   do(lfBundle)
           store(lf)                             set(lf) use(gLexicalFunction)
'\lv' nl > do(lfBundle)              c 1997-11-25 MRP
'\lv ' >  if(lv) do(lfBundle) endif  c 1997-11-25 MRP
          store(lv)                              set(lv) use(gField) set(v,vhm)
'\le ' > append(le) if(le) "}|fs{' '}|fe{" endif set(le) use(gField)
'\ln ' > append(ln) if(ln) "}|fs{' '}|fn{" endif set(ln) use(gField)
'\lr ' > append(lr) if(lr) "}|fs{' '}|fr{" endif set(lr) use(gField)

'\sy ' > append(sy) if(sy)  '|fs{; }'      endif set(sy) use(gField) set(v,vhm)
'\an ' > append(an) if(an)  '|fs{; }'      endif set(an) use(gField) set(v,vhm)

'\mr ' > append(mr) if(mr)  '|fs{; }'      endif set(mr) use(gField) set(v)

'\cf' nl > do(cfBundle)
'\cf ' >   do(cfBundle)
          store(cf)                              set(cf) use(gField) set(v,vhm)
'\ce ' > append(ce) if(ce) "}|fs{' '}|fe{" endif set(ce) use(gField)
'\cn ' > append(cn) if(cn) "}|fs{' '}|fn{" endif set(cn) use(gField)
'\cr ' > append(cr) if(cr) "}|fs{' '}|fr{" endif set(cr) use(gField)

'\mn ' > append(mn) if(mn)  '|fs{; }'      endif set(mn) use(gField) set(v,vhm)

'\va' nl > do(vaBundle)
'\va ' >   do(vaBundle)
          store(va)                              set(va) use(gField) set(v,vhm)
'\ve ' > append(ve) if(ve) '}|fs{) (}|fe{' endif set(ve) use(gField)
'\vn ' > append(vn) if(vn) '}|fs{) (}|fn{' endif set(vn) use(gField)
'\vr ' > append(vr) if(vr) '}|fs{) (}|fr{' endif set(vr) use(gField)

'\bw ' > append(bw) if(bw)      '; '       endif set(bw) use(gField)

'\et' nl > do(etBundle)
'\et ' >   do(etBundle)
          store(et)                              set(et) use(gField)
'\eg ' > append(eg) if(eg) "}|fs{' '}|fe{" endif set(eg) use(gField)
'\es ' > append(es) if(es)       " "       endif set(es) use(gField)
'\ec ' > append(ec) if(ec) "}|fs{) (}|fe{" endif set(ec) use(gField)

'\pd' nl > do(pdBundle)
'\pd ' >   do(pdBundle)
           store(pd)                                set(pd) use(gField)

'\pdl' nl > do(pdBundle)
'\pdl ' >   do(pdBundle)
           store(pdl)                               set(pdl) use(gField)
'\pdv' nl > do(pdBundle)               c 1997-12-01 MRP
'\pdv ' >  if(pdv) do(pdBundle) endif  c 1997-12-01 MRP
           store(pdv)                               set(pdv) use(gField) set(v,vhm)
'\pde ' > append(pde) if(pde) "}|fs{' '}|fe{" endif set(pde) use(gField)
'\pdn ' > append(pdn) if(pdn) "}|fs{' '}|fn{" endif set(pdn) use(gField)
'\pdr ' > append(pdr) if(pdr) "}|fs{' '}|fr{" endif set(pdr) use(gField)

'\sg ' > append(sg) ifneq(sg) '' begin '|fs{; }'   end endif use(gField) set(v,vhm)
'\pl ' > append(pl) ifneq(pl) '' begin '|fs{; }'   end endif use(gField) set(v,vhm)
'\rd ' > append(rd) ifneq(rd) '' begin '|fs{; }'   end endif use(gField) set(v,vhm)

'\1s ' > append(1s) ifneq(1s) '' begin '|fs{; }'   end endif use(gField)
'\2s ' > append(2s) ifneq(2s) '' begin '|fs{; }'   end endif use(gField)
'\3s ' > append(3s) ifneq(3s) '' begin '|fs{; }'   end endif use(gField)
'\4s ' > append(4s) ifneq(4s) '' begin '|fs{; }'   end endif use(gField)

'\1d ' > append(1d) ifneq(1d) '' begin '|fs{; }'   end endif use(gField)
'\2d ' > append(2d) ifneq(2d) '' begin '|fs{; }'   end endif use(gField)
'\3d ' > append(3d) ifneq(3d) '' begin '|fs{; }'   end endif use(gField)
'\4d ' > append(4d) ifneq(4d) '' begin '|fs{; }'   end endif use(gField)

'\1p ' > append(1p) ifneq(1p) '' begin '|fs{; }'   end endif use(gField)
'\1i ' > append(1i) ifneq(1i) '' begin '|fs{; }'   end endif use(gField)
'\1e ' > append(1e) ifneq(1e) '' begin '|fs{; }'   end endif use(gField)
'\2p ' > append(2p) ifneq(2p) '' begin '|fs{; }'   end endif use(gField)
'\3p ' > append(3p) ifneq(3p) '' begin '|fs{; }'   end endif use(gField)
'\4p ' > append(4p) ifneq(4p) '' begin '|fs{; }'   end endif use(gField)

'\tb' fol(WS) >
         append(tb) if(tb)       nl        endif set(tb) use(gField) dup

'\sd ' > append(sd) if(sd)  '|fs{; }'      endif set(sd) use(gField)
'\is ' > append(is) if(is)  '|fs{; }'      endif set(is) use(gField)
'\th ' > append(th) if(th)  '|fs{; }'      endif set(th) use(gField)

'\bb ' > append(bb) if(bb)      ' '        endif set(bb) use(gField)
'\pc ' > append(pc) if(pc)      '; '       endif set(pc) use(gField)

'\nt ' > append(nt) if(nt)      ' '        endif set(nt) use(gField)
'\np ' > append(np) if(np)      ' '        endif set(np) use(gField)
'\ng ' > append(ng) if(ng)      ' '        endif set(ng) use(gField)
'\nd ' > append(nd) if(nd)      ' '        endif set(nd) use(gField)
'\na ' > append(na) if(na)      ' '        endif set(na) use(gField)
'\ns ' > append(ns) if(ns)      ' '        endif set(ns) use(gField)
'\nq ' > append(nq) if(nq)      ' '        endif set(nq) use(gField)

'\so ' > append(so) if(so)      ' '        endif set(so) use(gField)
'\st ' > append(st) if(st)      '; '       endif set(st) use(gField)
'\dt ' > append(dt) if(dt)      '; '       endif set(dt) use(gField)


c 1996-08-10 MRP: Shoebox now inserts the new letter section.
c Unlike CTW, Sh3 RTF conversion applies the section's attributes,
c i.e. number of columns, to the text that FOLLOWS the break.
c 1996-08-15 MRP: Letter Paragraph and Letter Section
'\LP ' > store(LP) set(LP)
         c 1997-01-26 MRP: Section breaks needed only for double-column;
         c Letter Paragraph 1 style has the additional space after.
         if(TwoColumns) '\SS' nl '\LS' nl dup else '\LP1 ' endif
         '|LV{'  c 1996-08-15 MRP: Enclose letters in |LV{...}
         use(gRestOfNewLetter)

endfile > do(dEndfile)

c Omit field (copy over to use)

'\_'   > store(omit) use(gRestOfField)  c Shoebox internal field
'\'    > append(??) if(??) ' ' endif set(??) dup use(gField)  c Non-MDF

c --------------------------------------------------------------------
group(gRestOfField)

nl fol(Backslash) > endstore use(gMain)

endfile > next
nl endfile > do(dEndfile)

c ====================================================================
group(gField)

c special character styles handling
c space after colon means it's NOT a chr style
'fvlink: ' > next  c 1999-04-02 MRP
'fv: ' > dup
'fn: ' > dup
'fr: ' > dup
'fe: ' > dup
'fs: ' > dup
'fi: ' > dup
'fb: ' > dup
'fl: ' > dup
'uc: ' > dup
'ui: ' > dup
'ub: ' > dup

'fvlink:' > next  c 1999-04-02 MRP
'fv:' > '|fv{' set(chrMDF,chr) set(fv,v,vhm)  c Vernacular font
'fn:' > '|fn{' set(chrMDF,chr)                c National language font
'fr:' > '|fr{' set(chrMDF,chr)                c Regional language font
'fe:' > '|fe{' set(chrMDF,chr)                c English language font
'fs:' > '|fs{' set(chrMDF,chr)                c standard font
'fi:' > '|fi{' set(chrMDF,chr)                c italic font
'fb:' > '|fb{' set(chrMDF,chr)                c bold font
'fl:' > '|fl{' set(chrMDF,chr)                c label font
'ui:' > '|ui{' set(chrMDF,chr)                c underlined italic
'ub:' > '|ub{' set(chrMDF,chr)                c underlined bold

'uc:' > set(chrMDF) next                      c underlined character
'|u{' > if(v) 
          begin '|ub{' end                c underlined bold
        else
          begin                               c underlined italic or regular
            if(n) 
              begin 
                if(English) begin '|ui{' end else begin '|uc{' end
              end
            else
              begin     
                if(r) 
                  begin 
                    if(English) begin '|ui{' end else begin '|uc{' end
                  end
                else
                  begin 
                    if(English) begin '|uc{' end else begin '|ui{' end
                  end c end of if(r)...else... nesting
              end c end of if(n)...else... nesting
          end c end of if(v)...else... nesting
        set(chr)

'|i ' > next                                           c Manuscripter |i
'|i'  > set(chrMS) next
'|i{' > '|fi{' set(chr)

'|b ' > next                                           c Manuscripter |b
'|b'  > set(chrMS) next
'|b{' > '|fb{' set(chr)

'|r'  > if(chrMS) '}' clear(chrMS,chr) else dup endif  c Manuscripter |r

'|fvlink{' > '|fv{'  c 1999-04-02 MRP

'}' >
    if(chr) 
      begin
        clear(do_it)
        if(chrMDF) begin set(do_it) end
        if(chrMS) begin  set(do_it) end
        if(do_it) begin '}' end
        if(fv) begin clear(fv,v,vhm) end  c 1997-05-02 MRP Fix \xv uc:... uc:...
        clear(chrMDF,chrMS,chr)  c Turn off character style
      end
    dup  c Output the brace

any(punct) >
    if(chrMDF) 
      begin
        '}' clear(chrMDF,chr)  c Turn off character style
        if(fv) begin clear(fv,v,vhm) end  c 1997-05-02 MRP Fix \xv uc:... uc:...
      end
    dup  c Output the punctuation

any(number) > if(vhm) '|hm{' dup '}' else dup endif

'_'   > clear(do_it)  c Convert underline to space where needed
        if(chr) set(do_it) endif
        if(v) set(do_it) endif
        if(do_it) ' ' else dup endif

'-'   > clear(do_it)  c Convert hyphens to nonbreaking where needed
        if(chr) set(do_it) endif
        if(v) set(do_it) endif
        if(do_it) '|{_}' else dup endif  c 1997-12-04 MRP: |{_} notation
        
c any(WS) '-' > dup '|{_}' back(4)  c Convert leading hyphens to nonbreaking 
'-' prec(WS) > '|{_}'  c Convert leading hyphens to nonbreaking 

',' nl fol(Backslash) > next  c Disregard comma at end of field
nl fol(Backslash) >
    if(chr) '}' clear(chrMDF,chrMS,chr) endif  c Turn off character style
    endstore  c Stop storing
    clear(fv,v,vhm)  c Clear the vernacular switches
    clear(n)  c National
    clear(r)  c Regional
    use(gMain)  c Process the next field

nl fol(Newline) > ''  c Omit the newline that Shoebox inserts between records
nl >
    if(chrMDF) 
      begin
        '}' clear(chrMDF,chr)   c Turn off character style
        if(fv) begin clear(fv,v,vhm) end
      end       
    dup

nl endfile > next
endfile >
    if(chr) '}' clear(chrMDF,chrMS,chr) endif  c Turn off character style
    do(dEndfile)

c ====================================================================
group(gGloss)   c \ge, \gn, \gr

',' nl fol(Backslash) > next  c Disregard comma at end of field
nl fol(Backslash) > endstore use(gMain)

endfile > next
nl endfile > do(dEndfile)

'.'   > ' '  c Convert dots to spaces  KB
'_'   > ' '  c Convert underlines to spaces
' ; ' > ', '  c Give multiple glosses normal punctuation

nl fol(Newline) > ''  c Omit the newline that Shoebox inserts between records

c ====================================================================
group(gLexicalFunction)   c \lf

':' fol(Newline) > next
'=' fol(Newline) > store(omit) use(gRestOfField)  c No vernacular word

': ' > next
':'  > next
'= ' > next
'='  > store(lv) set(lv) use(gField) set(v)

' ' fol(LexicalFunctionSeparator) > ''  c Skip preceding space

nl fol(Backslash) > endstore use(gMain)

endfile > next
nl endfile > do(dEndfile)

c ====================================================================
group(gRestOfNewLetter)   c \LP New letter section heading

nl fol(Newline) > ''

nl fol(Backslash) >
    '}' nl  c 1996-08-15 MRP: Enclose letters in |LV{...}
    c 1997-01-26 MRP: Section breaks needed only for double-column
    if(TwoColumns) '\DS' nl endif  c 1996-08-15 MRP
    endstore use(gMain)

c END ===============================================================
